from Crypto.Util.number import *

n = 60116508546664196727889673537793426957208317552814539722187167053623876043252780386821990827068176541032744152377606007460695865230455445490316090376844822501259106343706524194509410859747044301510282354678419831232665073515931614133865254324502750265996406483174791757276522461194898225654233114447953162193
h = 2116009228641574188029563238988754314114810088905380650788213482300513708694199075187203381676605068292187173539467885447061231622295867582666482214703260097506783790268190834638040582281613892929433273567874863354164328733477933865295220796973440457829691340185850634254836394529210411687785425194854790919451644450150262782885556693980725855574463590558188227365115377564767308192896153000524264489227968334038322920900226265971146564689699854863767404695165914924865933228537449955231734113032546481992453187988144741216240595756614621211870621559491396668569557442509308772459599704840575445577974462021437438528
c = 50609945708848823221808804877630237645587351810959339905773651051680570682896518230348173309526813601333731054682678018462412801934056050505173324754946000933742765626167885199640585623420470828969511673056056011846681065748145129805078161435256544226137963588018603162731644544670134305349338886118521580925
e = 65537
m = n ** 2 + 69420
a = pow(3, 1011, m)
b = pow(5, 1011, m)

B = matrix(ZZ, [[m, 0, 0, 0], [-h, 1, 0, 0], [a ^ 2, 0, 1, 0], [b ^ 2, 0, 0, 1]])

load("solver.sage")  # https://github.com/rkm0959/Inequality_Solving_with_CVP
lb = [0, 1, 0, 0]
ub = [0, 1, 2 ^ 1024, 2 ^ 1024]
result, applied_weights, fin = solve(B, lb, ub)  # PS: B will be modified inplace
v = vector(
    [x // y for x, y in zip(result, applied_weights)]
)  # closest vector to (lb+ub)/2
print(v)
if not v[2].is_square():
    R = B.LLL()
    l0 = vector([x // y for x, y in zip(R[0], applied_weights)])
    l1 = vector([x // y for x, y in zip(R[1], applied_weights)])
    # enumerate nearby vectors
    for i in range(-10, 10):
        for j in range(-10, 10):
            vv = v + l0 * i + l1 * j
            if vv[2].is_square():
                print("found", i, j)
                p = vv[2].sqrt()
                q = vv[3].sqrt()
                assert p * q == n
                d = inverse_mod(e, (p - 1) * (q - 1))
                m = power_mod(c, d, n)
                print(long_to_bytes(m))

# FLAG{7hI5_i5_4_C0MPL373_r4nD0M_fL49_8LinK}
